"""Multi-pass segmentation logic."""

from typing import Tuple, List
import numpy as np
from scipy import ndimage

from sam_mosaic.config import SegmentationConfig, ThresholdConfig
from sam_mosaic.sam import SAMPredictor, Mask, apply_black_mask
from sam_mosaic.sam.masks import convert_masks_to_labels
from sam_mosaic.points import make_uniform_grid, make_kmeans_points


def run_multipass_segmentation(
    predictor: SAMPredictor,
    image: np.ndarray,
    seg_config: SegmentationConfig,
    threshold_config: ThresholdConfig,
    start_label: int = 1,
    min_region_area: int = 100
) -> Tuple[np.ndarray, np.ndarray, dict]:
    """Run multi-pass segmentation on a single tile/image.

    This implements the core multi-pass algorithm:
    1. First pass: Uniform grid with high threshold
    2. Subsequent passes: K-means in residual areas
    3. Black mask applied to focus SAM on unsegmented areas
    4. Threshold reduced only when progress is low
    5. Stop when target coverage reached or threshold exhausted

    Each mask from SAM is split into connected components, and small
    components (< min_region_area) are filtered out immediately.

    Args:
        predictor: SAM predictor (model loaded).
        image: RGB image array (H, W, 3).
        seg_config: Segmentation configuration.
        threshold_config: Threshold configuration.
        start_label: Starting label ID.
        min_region_area: Minimum area for a region to be kept (default 100).

    Returns:
        Tuple of (labels, combined_mask, stats).
    """
    height, width = image.shape[:2]
    total_pixels = height * width

    # Initialize
    combined_mask = np.zeros((height, width), dtype=np.uint8)
    tile_labels = np.zeros((height, width), dtype=np.uint32)
    current_label = start_label

    # Thresholds (adaptive)
    current_iou = threshold_config.iou_start
    current_stab = threshold_config.stability_start

    # Base grid for pass 0
    base_points = make_uniform_grid(height, width, seg_config.points_per_side)

    # Stats
    stats = {
        "passes": 0,
        "masks_per_pass": [],
        "coverage_per_pass": [],
        "final_coverage": 0.0,
        "total_masks": 0,
        # Detailed stats for ablation analysis
        "masks_generated_per_pass": [],    # Total masks from SAM (before filtering)
        "masks_filtered_overlap": 0,       # Filtered due to overlap > 50%
        "masks_filtered_small": 0,         # Filtered due to size < min_region_area
    }

    pass_idx = 0
    prev_coverage = 0.0

    while True:
        # Check max passes
        if seg_config.max_passes is not None and pass_idx >= seg_config.max_passes:
            break

        # Get points
        if pass_idx == 0:
            points = base_points
        else:
            # K-means points only in non-masked areas
            valid_mask = combined_mask == 0
            points = make_kmeans_points(valid_mask, n_points=64, erosion_iterations=10)

        if len(points) == 0:
            break

        # Apply black mask to image if enabled
        # On pass 0, combined_mask is zeros so this has no effect anyway
        if seg_config.use_black_mask:
            current_image = apply_black_mask(image, combined_mask)
        else:
            current_image = image

        # Predict masks (batched)
        masks = predictor.predict_points_batched(
            current_image,
            np.array(points),
            iou_threshold=current_iou,
            stability_threshold=current_stab
        )

        # Add masks that don't overlap too much with existing coverage
        # Split each mask into connected components and filter small ones
        masks_added = 0
        masks_filtered_small_pass = 0
        masks_filtered_overlap_pass = 0
        structure = ndimage.generate_binary_structure(2, 1)  # 4-connectivity (create once)

        # Count total masks generated by SAM this pass
        stats["masks_generated_per_pass"].append(len(masks))

        for m in masks:
            mask_data = m.data if hasattr(m, 'data') else m.mask
            if mask_data.sum() == 0:
                continue

            # Split into connected components
            labeled_mask, n_components = ndimage.label(mask_data > 0, structure=structure)

            if n_components == 0:
                continue

            # Fast path: single component (most common case)
            if n_components == 1:
                comp_area = mask_data.sum()
                if comp_area < min_region_area:
                    masks_filtered_small_pass += 1
                    continue

                overlap = (mask_data.astype(bool) & (combined_mask > 0)).sum()
                overlap_ratio = overlap / comp_area

                if overlap_ratio < 0.5:
                    combined_mask[mask_data > 0] = 1
                    tile_labels[(mask_data > 0) & (tile_labels == 0)] = current_label
                    current_label += 1
                    masks_added += 1
                else:
                    masks_filtered_overlap_pass += 1
            else:
                # Multiple components: get all areas at once with bincount
                comp_areas = np.bincount(labeled_mask.ravel(), minlength=n_components + 1)

                for comp_id in range(1, n_components + 1):
                    comp_area = comp_areas[comp_id]

                    # Filter small components
                    if comp_area < min_region_area:
                        masks_filtered_small_pass += 1
                        continue

                    # Create mask only for valid components
                    comp_mask = labeled_mask == comp_id

                    # Calculate overlap with existing coverage
                    overlap = (comp_mask & (combined_mask > 0)).sum()
                    overlap_ratio = overlap / comp_area

                    # Only add if less than 50% overlap
                    if overlap_ratio < 0.5:
                        combined_mask[comp_mask] = 1
                        tile_labels[comp_mask & (tile_labels == 0)] = current_label
                        current_label += 1
                        masks_added += 1
                    else:
                        masks_filtered_overlap_pass += 1

        # Accumulate filtered counts
        stats["masks_filtered_small"] += masks_filtered_small_pass
        stats["masks_filtered_overlap"] += masks_filtered_overlap_pass

        coverage = combined_mask.sum() / total_pixels * 100
        coverage_gain = coverage - prev_coverage

        stats["masks_per_pass"].append(masks_added)
        stats["coverage_per_pass"].append(coverage)

        # Stop if we reached target coverage
        if coverage >= seg_config.target_coverage:
            pass_idx += 1
            break

        # Adaptive threshold logic
        if len(masks) == 0 or masks_added == 0:
            # No masks generated or all filtered - reduce threshold
            if current_iou <= threshold_config.iou_end:
                break
            current_iou = max(threshold_config.iou_end, current_iou - threshold_config.step)
            current_stab = max(threshold_config.stability_end, current_stab - threshold_config.step)
        elif coverage_gain < 0.1:
            # Masks added but coverage didn't increase much - reduce threshold
            if current_iou <= threshold_config.iou_end:
                break
            current_iou = max(threshold_config.iou_end, current_iou - threshold_config.step)
            current_stab = max(threshold_config.stability_end, current_stab - threshold_config.step)

        prev_coverage = coverage
        pass_idx += 1

    # Finalize stats
    stats["passes"] = pass_idx
    stats["total_masks"] = current_label - start_label
    stats["final_coverage"] = combined_mask.sum() / total_pixels * 100
    stats["final_iou"] = current_iou

    return tile_labels, combined_mask, stats
